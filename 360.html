<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Viewer Photo 360</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    touch-action: none;
  }
  html, body, #fullscreenBtn {
    font-family: 'Space Grotesk', sans-serif;
  font-weight: 400;
  }

  #viewer {
    position: relative;
    width: 100%;
    height: 100%;
    background: black;
    overflow: hidden;
    cursor: grab;
  }

  canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: 0;
    object-fit: cover;
  }

  #overlay {
    position: absolute;
    inset: 0;
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    background-color: rgba(0,0,0,0.5);
    color: white;
    font-size: 20px;
    pointer-events: none;
    transition: opacity 0.5s ease;
    opacity: 1;
  }
  #overlay.hide { opacity: 0; }

  #fullscreenBtn {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 10000;
    background: rgba(109,145,188,0.6);
    color: white;
    border: none;
    padding: 8px 12px;
    font-size: 14px;
    border-radius: 5px;
    cursor: pointer;
  }
  #fullscreenBtn:hover {
    background: rgba(109,145,188,0.8);
  }
</style>
</head>
<body>

<div id="viewer">
  <div id="overlay">Glissez le doigt pour bouger la caméra</div>
  <button id="fullscreenBtn">Plein écran</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let isUserInteracting = false;
let lon = 0, lat = 0;
let phi = 0, theta = 0;
let onPointerDownLon = 0, onPointerDownLat = 0;
let onPointerDownX = 0, onPointerDownY = 0;
let prevX = 0, prevY = 0; // position précédente pendant le mouvement
let lastDx = 0, lastDy = 0;
let lastMoveTime = 0;
let autoRotateSpeed = 0.03;
let userHasInteracted = false;
let lonVelocity = 0;
let latVelocity = 0;
const inertia = 0.95; // plus proche de 1 = plus de glide
const sensitivity = 0.12;
const inertiaScale = 0.5; // facteur pour la vélocité calculée à partir du dernier delta

const container = document.getElementById('viewer');

// Get image URL from query parameters
const urlParams = new URLSearchParams(window.location.search);
const imageURL = urlParams.get('src') || '';

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 1, 1100);

  const geometry = new THREE.SphereGeometry(500, 60, 40);
  geometry.scale(-1, 1, 1);

  const texture = new THREE.TextureLoader().load(imageURL);
  const material = new THREE.MeshBasicMaterial({ map: texture });
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(container.clientWidth, container.clientHeight, false);
  renderer.domElement.style.position = 'absolute';
  renderer.domElement.style.inset = '0';
  renderer.domElement.style.zIndex = '0';
  container.appendChild(renderer.domElement);

  // Mouse & touch events
  container.addEventListener('pointerdown', onPointerDown);
  container.addEventListener('touchstart', onTouchStart, { passive: false });

  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('touchmove', onTouchMove, { passive: false });

  window.addEventListener('pointerup', onPointerUp);
  window.addEventListener('touchend', onPointerUp);

  window.addEventListener('resize', onWindowResize);

  // Overlay hide
  setTimeout(() => {
    const overlay = document.getElementById('overlay');
    overlay.classList.add('hide');
    setTimeout(() => overlay.style.display = 'none', 500);
  }, 2000);

  // Fullscreen button
  const fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      container.requestFullscreen().catch(err => {
        alert(`Erreur de plein écran : ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  });
}

function getRelativePosition(event) {
  const rect = container.getBoundingClientRect();
  return { x: event.clientX - rect.left, y: event.clientY - rect.top };
}

// Mouse
function onPointerDown(event) {
  isUserInteracting = true;
  userHasInteracted = true;
  const pos = getRelativePosition(event);
  onPointerDownX = pos.x;
  onPointerDownY = pos.y;
  onPointerDownLon = lon;
  onPointerDownLat = lat;

  // initialise prev pour calculer les deltas successifs
  prevX = pos.x;
  prevY = pos.y;
  lastDx = 0;
  lastDy = 0;
  lastMoveTime = performance.now();
  container.style.cursor = 'grabbing';
}

function onPointerMove(event) {
  if (!isUserInteracting) return;

  const pos = getRelativePosition(event);

  // delta total depuis le down (pour positionner la caméra)
  const dxTotal = onPointerDownX - pos.x;
  const dyTotal = pos.y - onPointerDownY;

  lon = dxTotal * sensitivity + onPointerDownLon;
  lat = dyTotal * sensitivity + onPointerDownLat;

  // delta depuis le dernier move (pour calculer la vélocité d'inertie)
  const dx = pos.x - prevX;
  const dy = pos.y - prevY;

  lastDx = dx;
  lastDy = dy;
  lastMoveTime = performance.now();

  // calcule une vélocité "instantanée" (direction cohérente avec lon/lat)
  lonVelocity = -lastDx * sensitivity * inertiaScale;
  latVelocity = lastDy * sensitivity * inertiaScale;

  prevX = pos.x;
  prevY = pos.y;
}

function onPointerUp() {
  isUserInteracting = false;
  container.style.cursor = 'grab';

  // Ne conserver l'inertie que si le dernier mouvement est récent et non-nul
  const now = performance.now();
  const timeSinceLastMove = now - lastMoveTime;
  const moveMagnitude = Math.hypot(lastDx, lastDy);

  const recentThresholdMs = 100; // si le dernier move est dans les 100ms
  const moveThresholdPx = 1;     // et le mouvement est > 1px

  if (!(timeSinceLastMove < recentThresholdMs && moveMagnitude > moveThresholdPx)) {
    // sinon on annule toute vélocité pour éviter l'inertie
    lonVelocity = 0;
    latVelocity = 0;
  }
}

// Touch
function onTouchStart(event) {
  if (event.touches.length === 1) {
    isUserInteracting = true;
    userHasInteracted = true;
    const touch = event.touches[0];
    onPointerDownX = touch.clientX;
    onPointerDownY = touch.clientY;
    onPointerDownLon = lon;
    onPointerDownLat = lat;

    prevX = touch.clientX;
    prevY = touch.clientY;
    lastDx = 0;
    lastDy = 0;
    lastMoveTime = performance.now();
  }
}

function onTouchMove(event) {
  if (!isUserInteracting || event.touches.length !== 1) return;
  event.preventDefault();

  const touch = event.touches[0];

  // delta total depuis le down (pour positionner la caméra)
  const dxTotal = onPointerDownX - touch.clientX;
  const dyTotal = touch.clientY - onPointerDownY;

  lon = dxTotal * sensitivity + onPointerDownLon;
  lat = dyTotal * sensitivity + onPointerDownLat;

  // delta depuis le dernier move (pour l'inertie)
  const dx = touch.clientX - prevX;
  const dy = touch.clientY - prevY;

  lastDx = dx;
  lastDy = dy;
  lastMoveTime = performance.now();

  lonVelocity = -lastDx * sensitivity * inertiaScale;
  latVelocity = lastDy * sensitivity * inertiaScale;

  prevX = touch.clientX;
  prevY = touch.clientY;
}


function onWindowResize() {
  const w = container.clientWidth || window.innerWidth;
  const h = container.clientHeight || window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h, false);
}

function animate() {
  requestAnimationFrame(animate);
  update();
}

function update() {
  if (!isUserInteracting) {
    lon += lonVelocity;
    lat += latVelocity;

    lonVelocity *= inertia;
    latVelocity *= inertia;

    // stop quand c’est très faible
    if (Math.abs(lonVelocity) < 0.001) lonVelocity = 0;
    if (Math.abs(latVelocity) < 0.001) latVelocity = 0;
  }

  if (!isUserInteracting && !userHasInteracted) {
    lon += autoRotateSpeed;
  }

  lat = Math.max(-85, Math.min(85, lat));
  phi = THREE.MathUtils.degToRad(90 - lat);
  theta = THREE.MathUtils.degToRad(lon);

  const target = new THREE.Vector3(
    500 * Math.sin(phi) * Math.cos(theta),
    500 * Math.cos(phi),
    500 * Math.sin(phi) * Math.sin(theta)
  );

  camera.lookAt(target);
  renderer.render(scene, camera);
}
</script>

</body>
</html>
